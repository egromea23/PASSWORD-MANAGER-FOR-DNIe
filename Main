#!/usr/bin/env python3
import argparse
import base64
import getpass
import os
import json
from datetime import datetime
import traceback

import Storage_functions
from state import state  # Importar la instancia global

PKCS11_LIB_PATH = r"C:\Program Files\OpenSC Project\OpenSC\pkcs11\opensc-pkcs11.dll"

# ---------------- AES-GCM ----------------
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

def aes_gcm_encrypt(plaintext: bytes, key: bytes=None) -> dict:
    if key is None:
        key = os.urandom(32)
    aesgcm = AESGCM(key)
    nonce = os.urandom(12)
    ciphertext = aesgcm.encrypt(nonce, plaintext, None)
    return {"key": key, "nonce": nonce, "ciphertext": ciphertext}

def aes_gcm_decrypt(key: bytes, nonce: bytes, ciphertext: bytes) -> bytes:
    aesgcm = AESGCM(key)
    return aesgcm.decrypt(nonce, ciphertext, None)

# ---------------- DNIe helpers ----------------
def try_import_pykcs11():
    try:
        import PyKCS11
        return PyKCS11
    except ImportError:
        raise RuntimeError("PyKCS11 no instalado. Inst√°lalo con: pip install PyKCS11")

def find_private_key_handle(session, PyKCS11):
    CKA_CLASS = PyKCS11.CKA_CLASS
    CKO_PRIVATE_KEY = PyKCS11.CKO_PRIVATE_KEY
    CKA_LABEL = PyKCS11.CKA_LABEL
    privs = session.findObjects([(CKA_CLASS, CKO_PRIVATE_KEY)])
    for pk in privs:
        try:
            label = session.getAttributeValue(pk, [CKA_LABEL])[0]
        except Exception:
            label = None
        if label and "Autenticacion" in str(label):
            return pk
    return privs[0] if privs else None

def sign_challenge_with_dnie(challenge: bytes, pin: str) -> bytes:
    PyKCS11 = try_import_pykcs11()
    pkcs11 = PyKCS11.PyKCS11Lib()
    pkcs11.load(PKCS11_LIB_PATH)
    slots = pkcs11.getSlotList(tokenPresent=True)
    if not slots:
        raise RuntimeError("No se detect√≥ token/lector con tarjeta insertada.")
    session = pkcs11.openSession(slots[0])
    try:
        session.login(pin)
    except PyKCS11.PyKCS11Error as e:
        session.closeSession()
        raise RuntimeError(f"Login fall√≥: {e}")
    try:
        priv = find_private_key_handle(session, PyKCS11)
        if priv is None:
            raise RuntimeError("No se encontr√≥ clave privada en el DNIe.")
        mech = PyKCS11.Mechanism(PyKCS11.CKM_SHA1_RSA_PKCS, None)
        signature = bytes(session.sign(priv, challenge, mech))
        return signature
    finally:
        try:
            session.logout()
        except Exception:
            pass
        session.closeSession()

def verify_signature_with_cert(signature: bytes, challenge: bytes, cert_der: bytes):
    from cryptography import x509
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives import hashes
    cert = x509.load_der_x509_certificate(cert_der)
    pub_key = cert.public_key()
    pub_key.verify(
        signature,
        challenge,
        padding.PKCS1v15(),
        hashes.SHA1()
    )

# ---------------- Comandos ----------------
def cmd_init(args):
    print("Inicializando base de datos...")
    if Storage_functions.DB_PATH.exists():
        print("La base de datos ya existe. Elimina passwords/passwords.db si quieres reinicializar.")
        return
    k_db = Storage_functions.generate_k_db()
    Storage_functions.init_empty_db(k_db)
    Storage_functions.update_metadata({
        "wrap_alg": "RAW_BASE64",
        "wrapped_key": base64.b64encode(k_db).decode()
    })
    state.init(k_db)  # <- usar el m√©todo init de state
    print("‚úÖ DB inicializada en RAW_BASE64 y desbloqueada en memoria.")

def cmd_wrap(args):
    if not state.unlocked or state.k_db is None:
        print("‚ùå No hay clave desbloqueada en memoria. Ejecuta init o unlock primero.")
        return

    meta = Storage_functions.read_metadata()
    if meta.get("wrap_alg") == "AES+DNIe":
        print("üîí DB ya est√° cifrada con AES+DNIe")
        return

    aes_blob = aes_gcm_encrypt(state.k_db)
    aes_key = aes_blob["key"]
    nonce = aes_blob["nonce"]
    ciphertext = aes_blob["ciphertext"]

    challenge = os.urandom(32)
    pin = getpass.getpass("Introduce PIN del DNIe: ")
    signature = sign_challenge_with_dnie(challenge, pin)

    Storage_functions.update_metadata({
        "enc_k_db": base64.b64encode(ciphertext).decode(),
        "aes_nonce": base64.b64encode(nonce).decode(),
        "aes_key_b64": base64.b64encode(aes_key).decode(),
        "challenge": base64.b64encode(challenge).decode(),
        "signature": base64.b64encode(signature).decode(),
        "wrap_alg": "AES+DNIe"
    })

    state.wrap()
    print("‚úÖ DB cifrada con AES+DNIe y bloqueada en memoria.")

def cmd_unlock(args):
    meta = Storage_functions.read_metadata()
    if not meta:
        print("‚ùå No hay metadata. Ejecuta init primero.")
        return

    if meta["wrap_alg"] == "RAW_BASE64":
        k_db = base64.b64decode(meta["wrapped_key"])
        state.unlock(k_db)
        print("‚úÖ DB desbloqueada en memoria (RAW).")
        return

    if meta["wrap_alg"] == "AES+DNIe":
        enc_k_db = base64.b64decode(meta["enc_k_db"])
        nonce = base64.b64decode(meta["aes_nonce"])
        aes_key = base64.b64decode(meta["aes_key_b64"])
        challenge = base64.b64decode(meta["challenge"])
        signature = base64.b64decode(meta["signature"])

        pin = getpass.getpass("Introduce PIN del DNIe: ")

        import PyKCS11
        pkcs11 = PyKCS11.PyKCS11Lib()
        pkcs11.load(PKCS11_LIB_PATH)
        slots = pkcs11.getSlotList(tokenPresent=True)
        if not slots:
            print("‚ùå No hay token/lector detectado.")
            return
        session = pkcs11.openSession(slots[0])
        certs_der = [bytes(session.getAttributeValue(obj, [PyKCS11.CKA_VALUE])[0])
                     for obj in session.findObjects([(PyKCS11.CKA_CLASS, PyKCS11.CKO_CERTIFICATE)])]
        session.closeSession()
        if not certs_der:
            print("‚ùå No se encontraron certificados en el token.")
            return

        try:
            verify_signature_with_cert(signature, challenge, certs_der[0])
        except Exception as e:
            print("‚ùå Firma DNIe inv√°lida:", e)
            return

        try:
            k_db = aes_gcm_decrypt(aes_key, nonce, enc_k_db)
            state.unlock(k_db)
            print("‚úÖ DB desbloqueada correctamente (AES+DNIe).")
        except Exception as e:
            print("‚ùå Error al descifrar AES:", e)
            traceback.print_exc()
        return
    try:
        k_db_json = json.loads(k_db.decode("utf-8"))
    except Exception:
        k_db_json = []

    Storage_functions.save_json_db(k_db_json)
    print("üìÑ Versi√≥n JSON creada en passwords/temp_db.json")

    print(f"‚ùå wrap_alg desconocido: {meta['wrap_alg']}")

def cmd_lock(args):
    if state.unlocked:
        state.lock()
        print("üîí DB bloqueada en memoria.")
    else:
        print("DB ya estaba bloqueada.")

def cmd_status(args):
    if state.unlocked:
        print("DB desbloqueada")
    else:
        print("DB bloqueada")


# ---------------- CRUD ----------------
def cmd_add(args):
    if not state.unlocked:
        print("‚ùå DB no desbloqueada. Ejecuta unlock primero.")
        return

    k_db_json = Storage_functions.load_json_db()
    new_entry = {
        "id": Storage_functions.get_next_id(k_db_json),
        "name": args.name,
        "username": args.username or "",
        "password": args.password or "",
        "notes": args.notes or "",
        "created": datetime.utcnow().isoformat() + "Z"
    }
    k_db_json.append(new_entry)
    k_db_json = sorted(k_db_json, key=lambda x: x["id"])
    Storage_functions.save_json_db(k_db_json)

    # Guardar archivo individual
    entries_dir = os.path.join("passwords", "entries_files")
    os.makedirs(entries_dir, exist_ok=True)
    entry_path = os.path.join(entries_dir, f"{new_entry['id']}_{new_entry['name']}.json")
    with open(entry_path, "w", encoding="utf-8") as f:
        json.dump(new_entry, f, indent=2, ensure_ascii=False)

    print(f"‚úÖ Entrada '{args.name}' a√±adida y DB ordenada.")
    print(f"üìÑ Archivo guardado en {entry_path}")

def cmd_list(args):
    if not state.unlocked:
        print("‚ùå DB no desbloqueada. Ejecuta unlock primero.")
        return

    k_db_json = Storage_functions.load_json_db()
    if not k_db_json:
        print("‚ö†Ô∏è No hay entradas guardadas.")
        return

    entries_dir = os.path.join("passwords", "entries_files")
    os.makedirs(entries_dir, exist_ok=True)

    print("Listado de entradas:")
    for entry in k_db_json:
        print(f"{entry['id']}: {entry['name']} ({entry['username']})")

        # Guardar cada entrada individual
        entry_path = os.path.join(entries_dir, f"{entry['id']}_{entry['name']}.json")
        with open(entry_path, "w", encoding="utf-8") as f:
            json.dump(entry, f, indent=2, ensure_ascii=False)

    print(f"üìÇ Archivos individuales guardados en {entries_dir}")

def cmd_get(args):
    if not state.unlocked:
        print("‚ùå DB no desbloqueada. Ejecuta unlock primero.")
        return

    k_db_json = Storage_functions.load_json_db()
    entry = next((e for e in k_db_json if e["id"] == args.id), None)
    if not entry:
        print("‚ùå Entrada no encontrada.")
        return

    print(json.dumps(entry, indent=2, ensure_ascii=False))

    entries_dir = os.path.join("passwords", "entries_files")
    os.makedirs(entries_dir, exist_ok=True)
    entry_path = os.path.join(entries_dir, f"{entry['id']}_{entry['name']}_get.json")
    with open(entry_path, "w", encoding="utf-8") as f:
        json.dump(entry, f, indent=2, ensure_ascii=False)

    print(f"üìÑ Archivo guardado en {entry_path}")

def cmd_edit(args):
    if not state.unlocked:
        print("‚ùå DB no desbloqueada. Ejecuta unlock primero.")
        return

    k_db_json = Storage_functions.load_json_db()
    entry = next((e for e in k_db_json if e["id"] == args.id), None)
    if not entry:
        print("‚ùå Entrada no encontrada.")
        return

    print(f"Editando entrada ID {args.id} (dejar vac√≠o para no cambiar):")

    new_name = input(f"Nombre [{entry['name']}]: ") or entry["name"]
    new_username = input(f"Username [{entry['username']}]: ") or entry["username"]
    new_password = input(f"Password [{entry['password']}]: ") or entry["password"]
    new_notes = input(f"Notas [{entry['notes']}]: ") or entry["notes"]

    entry.update({
        "name": new_name,
        "username": new_username,
        "password": new_password,
        "notes": new_notes
    })

    # Guardar DB actualizada
    Storage_functions.save_json_db(k_db_json)

    # Guardar archivo individual actualizado
    entries_dir = os.path.join("passwords", "entries_files")
    os.makedirs(entries_dir, exist_ok=True)
    entry_path = os.path.join(entries_dir, f"{entry['id']}_{entry['name']}.json")
    with open(entry_path, "w", encoding="utf-8") as f:
        json.dump(entry, f, indent=2, ensure_ascii=False)

    print(f"‚úÖ Entrada ID {args.id} actualizada correctamente.")
    print(f"üìÑ Archivo actualizado en {entry_path}")


# ---------------- CLI ----------------
def main():
    parser = argparse.ArgumentParser(
        description="Password Manager con DNIe"
    )
    sub = parser.add_subparsers(dest="command", title="Comandos disponibles")

    sub.add_parser("init", help="Inicializar base de datos")
    sub.add_parser("wrap", help="Cifrar DB con DNIe (AES + challenge)")
    sub.add_parser("unlock", help="Desbloquear DB usando PIN del DNIe")
    sub.add_parser("lock", help="Bloquear DB en memoria")
    sub.add_parser("status", help="Estado DB")

    p_add = sub.add_parser("add", help="A√±adir entrada")
    p_add.add_argument("name")
    p_add.add_argument("-u", "--username")
    p_add.add_argument("-p", "--password")
    p_add.add_argument("-n", "--notes")

    sub.add_parser("list", help="Listar entradas")
    p_get = sub.add_parser("get", help="Obtener entrada por ID")
    p_get.add_argument("id", type=int)

    p_edit = sub.add_parser("edit", help="Editar entrada por ID")
    p_edit.add_argument("id", type=int)
    p_edit.add_argument("-n", "--name")
    p_edit.add_argument("-u", "--username")
    p_edit.add_argument("-p", "--password")
    p_edit.add_argument("-t", "--notes")

    args = parser.parse_args()

    if args.command == "init": cmd_init(args)
    elif args.command == "wrap": cmd_wrap(args)
    elif args.command == "unlock": cmd_unlock(args)
    elif args.command == "lock": cmd_lock(args)
    elif args.command == "status": cmd_status(args)
    elif args.command == "add": cmd_add(args)
    elif args.command == "list": cmd_list(args)
    elif args.command == "get": cmd_get(args)
    elif args.command == "edit": cmd_edit(args)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
